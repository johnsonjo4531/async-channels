{"mappings":"AAAA,aAAa,CAAC,IAAI,CAAC,SAAS,IAAI,GAAG,SAAS,GACxC,CAAC,GACD,CAAC,SAAS,MAAM,GAAG;IACjB,IAAI,CAAC,WAAW,EAAE,MAAM,CAAC,GAAG,GAAG,CAAC;CACjC,GACD,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,GAAG,IAAI,EAAE,GAAG,KAAK,GAAG,GAC7C,QAAQ,CAAC,CAAC,GACV,KAAK,GACP,CAAC,CAAC;AACN,uBAAuB,CAAC,IACpB,2BAA2B,CAAC,CAAC,CAAC,GAC9B,uBAAuB,OAAO,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;AAChD,4BAA4B,IAAI,EAAE,OAAO,EAAE,eAAe,IAAI;IAC5D,OAAO,EAAE,MAAM,OAAO,CAAC,eAAe,GAAG,SAAS,CAAC,CAAC;IACpD,UAAU,EAAE,MAAM,cAAc,CAC9B,QAAQ,eAAe,CAAC,GAAG,SAAS,EACpC,IAAI,EACJ,GAAG,CACJ,CAAC;IACF,MAAM,EAAE,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;IAC5B,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,KAAK,OAAO,CAAC,KAAK,CAAC,CAAC;IACpC,IAAI,EAAE,CAAC,MAAM,EAAE,IAAI,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;IACtC,YAAY,EAAE,CAAC,MAAM,EAAE,kBAAkB,eAAe,CAAC,KAAK,IAAI,CAAC;IACnE,MAAM,EAAE,2BAA2B,CAAC,OAAO,CAAC,CAAC;IAC7C,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,uBACtB,IAAI,EACJ,OAAO,EACP,eAAe,CAChB,CAAC,YAAY,CAAC,CAAC;CACjB,CAAC;AAqGF,qCAAqC,YAAY,EAAE,YAAY,mJAa9D","sources":["src/src/async-channel.ts","src/async-channel.ts"],"sourcesContent":[null,"type Awaited<T> = T extends null | undefined\n  ? T\n  : T extends object & {\n      then(onfulfilled: infer F): any;\n    }\n  ? F extends (value: infer V, ...args: any) => any\n    ? Awaited<V>\n    : never\n  : T;\ntype ChannelReaderType<T> =\n  | ReadableStreamDefaultReader<T>\n  | AsyncChannelController<unknown, T, unknown>;\ntype AsyncChannelController<Send, Receive, ExternalReceive> = {\n  receive: () => Promise<ExternalReceive | undefined>;\n  receiveAll: () => AsyncGenerator<\n    Awaited<ExternalReceive> | undefined,\n    void,\n    any\n  >;\n  return: () => Promise<void>;\n  throw: (err: any) => Promise<never>;\n  send: (output: Send) => Promise<void>;\n  assignReader: (reader: ChannelReaderType<ExternalReceive>) => void;\n  reader: ReadableStreamDefaultReader<Receive>;\n  [Symbol.asyncIterator]: AsyncChannelController<\n    Send,\n    Receive,\n    ExternalReceive\n  >[\"receiveAll\"];\n};\n\nasync function* consumeStream<T>(\n  stream: ReadableStreamDefaultReader<T>,\n  onExit: {\n    throw: (err?: any) => Promise<never> | never;\n    return: () => Promise<void> | void;\n  }\n) {\n  try {\n    let done, value;\n    do {\n      ({ done, value } = await stream.read());\n      if (done) continue;\n      yield value;\n    } while (!done);\n  } catch (err) {\n    return onExit.throw(err);\n  } finally {\n    return onExit.return();\n  }\n}\n\nfunction getReader<T>(\n  reader:\n    | ReadableStreamDefaultReader<T>\n    | AsyncChannelController<unknown, T, unknown>\n) {\n  if (reader instanceof ReadableStreamDefaultReader) {\n    return reader;\n  } else if (\"reader\" in reader) {\n    return reader.reader;\n  }\n}\n\n/** */\nfunction AsyncChannel<\n  ChannelInternalSend,\n  ChannelInternalReceive,\n  ChannelExternalReceive\n>(\n  reader?: ChannelReaderType<ChannelExternalReceive>\n): AsyncChannelController<\n  ChannelInternalSend,\n  ChannelInternalReceive,\n  ChannelExternalReceive\n> {\n  let _reader: ReadableStreamDefaultReader<ChannelExternalReceive> | undefined =\n    typeof reader === \"undefined\" ? undefined : getReader(reader);\n  // type InternalReceive = ExternalSend;\n  const internalStream = new TransformStream<\n    ChannelInternalSend,\n    ChannelInternalReceive\n  >();\n  const [internalReader, writer] = [\n    internalStream.readable.getReader(),\n    internalStream.writable.getWriter(),\n  ];\n\n  async function cleanup() {\n    await Promise.allSettled([\n      internalStream.writable.close(),\n      internalStream.readable.cancel(),\n    ]);\n  }\n\n  return {\n    async receive() {\n      if (!_reader)\n        throw new Error(\n          \"No reader available you must either pass in a reader at initialization or assign one later.\"\n        );\n      return (await _reader.read())?.value;\n    },\n    receiveAll: async function* receiveAll() {\n      if (!_reader)\n        throw new Error(\n          \"No reader available you must either pass in a reader at initialization or assign one later.\"\n        );\n      yield* consumeStream<ChannelExternalReceive>(_reader, this);\n    },\n    async return() {\n      await cleanup();\n    },\n    async throw(err: any) {\n      await cleanup();\n      throw err;\n    },\n    async send(data) {\n      return writer.write(data);\n    },\n    assignReader(newExternalReader) {\n      _reader = getReader(newExternalReader);\n    },\n    reader: internalReader,\n    [Symbol.asyncIterator]() {\n      return this.receiveAll();\n    },\n  } as const;\n}\n\nexport function intermingledChannels<Channel1Send, Channel2Send>() {\n  type Channel2Receive = Channel1Send;\n  type Channel1Receive = Channel2Send;\n  const controller1 = AsyncChannel<\n    Channel1Send,\n    Channel1Send,\n    Channel1Receive\n  >();\n  const controller2 = AsyncChannel<Channel2Send, Channel2Send, Channel2Receive>(\n    controller1.reader\n  );\n  controller1.assignReader(controller2.reader);\n  return [controller1, controller2] as const;\n}\n"],"names":[],"version":3,"file":"async-channel.d.ts.map"}