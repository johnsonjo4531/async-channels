{"mappings":";;;;;AAuBA,gBAAgB,mCAAa,CAC3B,MAAsC,EACtC,MAGC,EACD;IACA,IAAI;QACF,IAAI,IAAI,EAAE,KAAK,AAAC;QAChB,GAAG;YACA,CAAA,QAAE,IAAI,CAAA,SAAE,KAAK,CAAA,EAAE,GAAG,MAAM,MAAM,CAAC,IAAI,EAAE,CAAA,CAAE;YACxC,IAAI,IAAI,EAAE,SAAS;YACnB,MAAM,KAAK,CAAC;SACb,OAAQ,CAAC,IAAI,EAAE;KACjB,CAAC,OAAO,GAAG,EAAE;QACZ,OAAO,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;KAC1B,QAAS;QACR,OAAO,MAAM,CAAC,MAAM,EAAE,CAAC;KACxB;CACF;AAED,SAAS,+BAAS,CAChB,MAE+C,EAC/C;IACA,IAAI,MAAM,YAAY,2BAA2B,EAC/C,OAAO,MAAM,CAAC;SACT,IAAI,QAAQ,IAAI,MAAM,EAC3B,OAAO,MAAM,CAAC,MAAM,CAAC;CAExB;AAED,MAAM,CACN,SAAS,kCAAY,CAKnB,MAAkD,EAKlD;IACA,IAAI,OAAO,GACT,OAAO,MAAM,KAAK,WAAW,GAAG,SAAS,GAAG,+BAAS,CAAC,MAAM,CAAC,AAAC;IAChE,uCAAuC;IACvC,MAAM,cAAc,GAAG,IAAI,eAAe,EAGvC,AAAC;IACJ,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC,GAAG;QAC/B,cAAc,CAAC,QAAQ,CAAC,SAAS,EAAE;QACnC,cAAc,CAAC,QAAQ,CAAC,SAAS,EAAE;KACpC,AAAC;IAEF,eAAe,OAAO,GAAG;QACvB,MAAM,OAAO,CAAC,UAAU,CAAC;YACvB,cAAc,CAAC,QAAQ,CAAC,KAAK,EAAE;YAC/B,cAAc,CAAC,QAAQ,CAAC,MAAM,EAAE;SACjC,CAAC,CAAC;KACJ;IAED,OAAO;QACL,MAAM,OAAO,IAAG;YACd,IAAI,CAAC,OAAO,EACV,MAAM,IAAI,KAAK,CACb,6FAA6F,CAC9F,CAAC;YACJ,OAAQ,CAAA,MAAM,OAAO,CAAC,IAAI,EAAE,CAAA,EAAG,KAAK,CAAC;SACtC;QACD,UAAU,EAAE,gBAAgB,UAAU,GAAG;YACvC,IAAI,CAAC,OAAO,EACV,MAAM,IAAI,KAAK,CACb,6FAA6F,CAC9F,CAAC;YACJ,OAAO,mCAAa,CAAyB,OAAO,EAAE,IAAI,CAAC,CAAC;SAC7D;QACD,MAAM,MAAM,IAAG;YACb,MAAM,OAAO,EAAE,CAAC;SACjB;QACD,MAAM,KAAK,EAAC,GAAQ,EAAE;YACpB,MAAM,OAAO,EAAE,CAAC;YAChB,MAAM,GAAG,CAAC;SACX;QACD,MAAM,IAAI,EAAC,IAAI,EAAE;YACf,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC3B;QACD,YAAY,EAAC,iBAAiB,EAAE;YAC9B,OAAO,GAAG,+BAAS,CAAC,iBAAiB,CAAC,CAAC;SACxC;QACD,MAAM,EAAE,cAAc;QACtB,CAAC,MAAM,CAAC,aAAa,CAAC,IAAG;YACvB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;SAC1B;KACF,CAAU;CACZ;AAEM,SAAS,yCAAoB,GAA+B;IAGjE,MAAM,WAAW,GAAG,kCAAY,EAI7B,AAAC;IACJ,MAAM,WAAW,GAAG,kCAAY,CAC9B,WAAW,CAAC,MAAM,CACnB,AAAC;IACF,WAAW,CAAC,YAAY,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;IAC7C,OAAO;QAAC,WAAW;QAAE,WAAW;KAAC,CAAU;CAC5C","sources":["src/async-channel.ts"],"sourcesContent":["type Awaited<T> = T extends Promise<infer J> ? J : T;\ntype ChannelReaderType<T> =\n  | ReadableStreamDefaultReader<T>\n  | AsyncChannelController<unknown, T, unknown>;\ntype AsyncChannelController<Send, Receive, ExternalReceive> = {\n  receive: () => Promise<ExternalReceive | undefined>;\n  receiveAll: () => AsyncGenerator<\n    Awaited<ExternalReceive> | undefined,\n    void,\n    any\n  >;\n  return: () => Promise<void>;\n  throw: (err: any) => Promise<never>;\n  send: (output: Send) => Promise<void>;\n  assignReader: (reader: ChannelReaderType<ExternalReceive>) => void;\n  reader: ReadableStreamDefaultReader<Receive>;\n  [Symbol.asyncIterator]: AsyncChannelController<\n    Send,\n    Receive,\n    ExternalReceive\n  >[\"receiveAll\"];\n};\n\nasync function* consumeStream<T>(\n  stream: ReadableStreamDefaultReader<T>,\n  onExit: {\n    throw: (err?: any) => Promise<never> | never;\n    return: () => Promise<void> | void;\n  }\n) {\n  try {\n    let done, value;\n    do {\n      ({ done, value } = await stream.read());\n      if (done) continue;\n      yield value;\n    } while (!done);\n  } catch (err) {\n    return onExit.throw(err);\n  } finally {\n    return onExit.return();\n  }\n}\n\nfunction getReader<T>(\n  reader:\n    | ReadableStreamDefaultReader<T>\n    | AsyncChannelController<unknown, T, unknown>\n) {\n  if (reader instanceof ReadableStreamDefaultReader) {\n    return reader;\n  } else if (\"reader\" in reader) {\n    return reader.reader;\n  }\n}\n\n/** */\nfunction AsyncChannel<\n  ChannelInternalSend,\n  ChannelInternalReceive,\n  ChannelExternalReceive\n>(\n  reader?: ChannelReaderType<ChannelExternalReceive>\n): AsyncChannelController<\n  ChannelInternalSend,\n  ChannelInternalReceive,\n  ChannelExternalReceive\n> {\n  let _reader: ReadableStreamDefaultReader<ChannelExternalReceive> | undefined =\n    typeof reader === \"undefined\" ? undefined : getReader(reader);\n  // type InternalReceive = ExternalSend;\n  const internalStream = new TransformStream<\n    ChannelInternalSend,\n    ChannelInternalReceive\n  >();\n  const [internalReader, writer] = [\n    internalStream.readable.getReader(),\n    internalStream.writable.getWriter(),\n  ];\n\n  async function cleanup() {\n    await Promise.allSettled([\n      internalStream.writable.close(),\n      internalStream.readable.cancel(),\n    ]);\n  }\n\n  return {\n    async receive() {\n      if (!_reader)\n        throw new Error(\n          \"No reader available you must either pass in a reader at initialization or assign one later.\"\n        );\n      return (await _reader.read())?.value;\n    },\n    receiveAll: async function* receiveAll() {\n      if (!_reader)\n        throw new Error(\n          \"No reader available you must either pass in a reader at initialization or assign one later.\"\n        );\n      yield* consumeStream<ChannelExternalReceive>(_reader, this);\n    },\n    async return() {\n      await cleanup();\n    },\n    async throw(err: any) {\n      await cleanup();\n      throw err;\n    },\n    async send(data) {\n      return writer.write(data);\n    },\n    assignReader(newExternalReader) {\n      _reader = getReader(newExternalReader);\n    },\n    reader: internalReader,\n    [Symbol.asyncIterator]() {\n      return this.receiveAll();\n    },\n  } as const;\n}\n\nexport function intermingledChannels<Channel1Send, Channel2Send>() {\n  type Channel2Receive = Channel1Send;\n  type Channel1Receive = Channel2Send;\n  const controller1 = AsyncChannel<\n    Channel1Send,\n    Channel1Send,\n    Channel1Receive\n  >();\n  const controller2 = AsyncChannel<Channel2Send, Channel2Send, Channel2Receive>(\n    controller1.reader\n  );\n  controller1.assignReader(controller2.reader);\n  return [controller1, controller2] as const;\n}\n"],"names":[],"version":3,"file":"async-channel.js.map"}